# Linux编程的概念
## 文件和文件系统
- 文件必须打开才能访问，文件打开方式有只读，只写和读写模式，文件打开后内核会分配一个文件描述符返回给用户空间应用，用户空间应用通过文件描述符来访问该文件。
### 普通文件
- 普通文件包含以字节流（即线性数组）组织的数据。
- 对文件内容的操作总是从某个位置（可以是任意字节）开始，即文件“地址”，又称为文件位置（file location）或文件偏移（file offset）。
### 目录和链接

### 硬链接
- 硬链接支持多个路径指向同一个inode
- 硬链接不能跨文件系统
- 硬链接不支持目录
- ln target link_name
- unlink link_name
- rm link_name
### 符号链接
- 符号链接支持目录，支持跨文件系统
- ln -s target link_name
- unlink link_name
- rm link_name
### 特殊文件
- 字符设备文件，作为线性字节队列来访问。
- 块设备文件，作为字节数组来访问
- 命名管道
- UNIX套接字
### 文件系统和命名空间
- 文件系统是以合理有效的层次结构组织的文件和目录的集合，在文件和目录的全局命名空间中可以分别添加和删除文件系统，这些操作mounting和unmounting，每个文件系统都需要挂载到命名空间的特定位置 即挂载点（mount point）。
- 第一个被挂载的文件系统是在命名空间的根目录/下，称为根文件系统，Linux系统必须有一个根文件系统，而其他文件系统是可选的。

## 进程
### 线程
### 进程层次结构

## 用户和组

## 权限

## 信号

# 文件IO
- 内核会为每个进程维护一个打开文件的列表，该列表称为文件表（file table），文件表由非负整数进行索引，这些非负整数称为文件描述符（file descriptors，简称fds）。列表的每一项是一个打开文件的信息，包括指向该文件索引节点（inode）内存拷贝的指针以及关联的元数据，如文件位置指针和访问模式。用户空间和内核空间都使用文件描述符作为唯一cookies：打开文件会返回文件描述符，后后续的操作（读写等）都把文件描述符作为基本参数。
- 文件描述符使用C语言的int类型表示。每个Linux进程可打开的文件数是有上限的。文件描述符的范围从1开始，到上限值减一。默认情况下上限值为1024，可以配置这个上限值，最大为1048576.
- 按照惯例，每个进程都至少包含三个文件描述符：0、1和2，除非显示关闭这些描述符。0表示标准输入（stdin），1表示标准输出（stdout），2表示标准错误（stderr）
- 默认情况下，子进程会维护一份父进程的文件表副本。在该副本中打开文件列表及其访问模式，当前文件位置以及其他元数据，都和父进程维护的文件表相同，但是存在一点区别：即当子进程关闭一个文件时，不会影响到父进程的文件表。虽然一般情况下子进程会自己持有一份文件表，但是子进程也可以和父进程共享文件表。
## 文件打开
- 在访问文件之前，必须先通过open()或creat()打开该文件，一旦完成文件读写，还应通过close()关闭该文件.
### 系统调用open()
- int open(const char *name, int flags)
- int open(const char *name, int flags, mode_t mode)
#### open()的flags参数
- flags参数是由一个或多个标志位的按位或组合。它支持三种访问模式：O_RDONLY、O_WRONLY或O_RDWR.
- flags参数还可以和下面这些值进行按位或运算，以修改打开文件的行为：O_APPEND, O_ASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME+, O_NOCTTY, O_NOFOLLOW,O_NONBLOCK, O_SYNC, O_TRUNC
#### 新建文件的所有者
- 确定新建文件的所有者很简单：文件所有者的uid即创建该文件的进程的有效uid。
- 确定新建文件的用户组则相对复杂，默认情况下，使用创建进程的有效gid，System V 和标准Linux都采用这种方式，BSD则有自己的行为方式。
#### 新建文件的权限 - open()的mode参数
- 除非创建了新文件，否则mode参数会被忽略.
- 如果给定O_CREAT flag, 则需要该参数;如果在使用O_CREAT flag时未提供mode参数，结果是未定义的，而且通常很糟糕。
- 当创建文件时，参数mode提供了文件的权限。对于新建的文件，打开文件时不会检查权限，因此可以执行与权限相反的操作，比如以只读方式打开时，却在打开后执行写操作。
- 实际上，最终写入磁盘的权限位是由mode参数和用户的文件创建掩码（umask）执行按位与操作而得到的。umask是进程级属性，通常是由login shell设置，通过调用umask()来修改，支持用户修改新创建的文件和目录的权限。
- 对于系统程序员，在设置权限时通常不需要考虑umask。 为了能限制程序对于新建文件的权限位设置，才有了umask。
### 系统调用creat()
- int creat(const char *name, mode_t mode)
- O_WRONLY|O_CREAT|O_TRUNC的组合经常被使用，因而专门有了这个系统调用。
### 返回值和错误码
- 系统掉调用open和creat在成功时都会返回文件描述符。出错时返回-1，并把errno设置成相应的错误值。
## 文件读
### 定义
- ssize_t read(int fd, void *buf, size_t len)
- 每次调用read函数，会从fd指向的文件的当前偏移开始读取len字节到buf所指向的内存中。执行成功时返回写入buf中的字节数；出错时返回-1，并把errno设置成相应的错误值。
- fd的文件位置指针会向前移动，移动的长度由读取到的字节数决定。如果fd所指向的对象不支持seek操作（比如字符设备文件），则读操作总是从当前位置开始。
### 返回值
- 调用返回值等于len。读取到的所有len个字节都被存储在buf中。结果和预期一致。
- 调用返回值小于len，大于0.读取到的字节被存储在buf中。这种情况有很多原因，比如在读取过程中信号中断或在读取中出错，可读的数据大于0小于len，在读取len字节之前EOF等等，再次执行read会把剩余的字节读到buf或者给出错误信息。
- 调用返回0，表示EOF，没有更多可读的数据。
- 由于当前没有数据可用，调用阻塞。在非阻塞模式下不会发生这种情况。
- 返回-1，并把errno设置成EINTR. 表示在读取任何字节之前接收到信号，调用可以重新执行。
- 返回-1，并把errno设置成EAGAIN. 表示由于当前没有数据可用，读操作会阻塞，请求应该稍后再重新执行。这种情况只在非阻塞模式下发生。
- 返回-1，并把errno设置成非EINTR和EAGAIN的一个值.这表示更严重的错误。重新执行不会成功。
## 文件写
### 定义
- ssize_t write(int fd, const void *buf, size_t count)
- write()调用会从文件描述符fd指向的文件的当前位置开始，将buf中至多count个字节写入到文件中。不支持seek的文件（如字符设备）总是从起始位置开始写。
- write()执行成功时，会返回写入的字节数，并更新文件位置。出错时，返回-1，并设置errno值。调用write会返回0,这种返回值没有任何特殊含义，它只是表示写入了零个字节。
### 部分写（Partial Write）
- 对于普通文件，除非发生错误，write操作保证乎会执行整个写请求；但对于其他的文件类型，比如socket，需要循环来保证写了所有请求的字节。使用循环的另一个好处是第二次调用write可能会返回错误值，说明第一次调用为什么只执行了部分写（虽然这种情况并不常见）。
### Append（追加）模式
- 当以Append模式（O_APPEND）打开文件描述符时，写操作不是从文件描述符的当前位置开始，而是从当前文件的末尾开始。
- Append模式可以保证文件位置指针总是执行文件末尾，因此即使存在多个写进程，所有的写操作还是能够保证是追加写。
- Append模式对于某些任务很有用，比如日志文件更新，但对其他很多操作意义不大。
### 非阻塞写
- 以非阻塞模式（O_NONBLOCK）打开文件，当发起写操作时，系统调用会返回-1，并设置errno为EAGAIN。请求可以稍后重新发起。一般而言，对于普通文件，不会出现这种情况。
### write的行为 - 延迟写与写缓冲
- 当write调用返回时，内核已经把数据从提供的缓冲区中拷贝到内核缓冲区中，但不保证数据已经写入目的地。实际上，write调用执行非常快，因此不可能保证数据 已经写到目的地。处理器和硬盘之间的性能差异使得这种情况非常明显。
- 当用户空间发起write系统调用时，Linux内核会做几项检查，然后直接把数据拷贝到缓冲区中，然后在后台，内核收集所有这样的“脏”缓冲区（即存贮的数据比磁盘上的数据新），进行排序优化，然后把这些缓冲区写到磁盘上（这个过程称为回写writeback）。
- 延迟写并没有改变POSIX语义。假设要对一份刚写到缓冲区还没有写到磁盘的数据执行读操作，请求响应时会直接读取缓冲区的数据，而不是读取磁盘上陈旧的数据。
- 延迟写的另一个问题在于无法强制“顺序写(write ordering)”。虽然应用可能会考虑对写请求进行排序，按特定顺序写入磁盘；而内核主要是出于性能考虑，按照合适的方式对写请求重新排序，只有当系统出现崩溃时延迟些才会有问题。
- 实际上绝大多数应用并不关心写顺序，数据库是少数几个关心顺序的，它们希望写操作有序以确保数据库不会处于不一致的状态。
## 同步I/O
### fsync（）
- int fsync(int fd)
- 系统调用fsync可以确保和文件描述符fd所指向的文件相关的所有脏数据都会回写到磁盘上。文件描述符fd必须以写方式打开，该调用会回写数据和元数据，如创建的时间戳以及索引节点中的其他属性。该调用在硬件驱动器确认数据和元数据已经全部写到磁盘之前不会返回。
- 对于包含写缓存的硬盘，fsync无法知道数据是否已经真正在物理磁盘上了；硬盘会报告说数据已经写完了，但是实际上数据还在硬盘驱动器的写缓存上，不过好在硬盘驱动器缓存中的数据很快会写到磁盘上。
- fsync通常会涉及至少两个I/O操作：一是回写修改的数据，二是更新索引节点的时间戳。因为索引节点和文件数据在磁盘上可能不是紧挨着，因而会带来代价很高的seek操作。
- 成功时，返回0，失败时返回-1并设置errno为：EBADF， EINVAL， EIO
### fdatasync()
- int fdatasync(int fd)
- 这两个函数都不保证已经更新的包含该文件的目录项会同步到磁盘上，为了保证对目录项的更新也同步到磁盘上，必须对文件目录也调用fsync进行同步。
- 在POSIX标准中，fsync是必要的，而fdatasync是可选的。
- 成功时，返回0，失败时返回-1并设置errno为：EBADF， EINVAL， EIO
### sync()
- void sync(void)
- sync()系统调用用来对磁盘上的所有缓冲区进行同步，该函数没有参数也没有返回值。它总是成功返回，并确保所有的缓冲区（数据和元数据）都能够写入磁盘。
- POSIX标准并不要求sync一直等待所有缓冲区都写到磁盘才返回，只需要调用它来启动把所有缓冲区写到磁盘即可，因此建议多次调用以确保全部数据都被安全的写入。
- 对于Linux，sync一定是等到所有缓冲区的数据都写入了才会返回，因此只需调用一次就够了。
### O_SYNC标志位
- 系统调用open可以使用O_SYNC标志位，表示该文件的所有I/O操作都需要同步。
- O_SYNC标志位的功能可以理解为每次调用write操作后，隐式执行fsync，然后才返回。
- 对于写操作，O_SYNC带来的时间开销(用户空间和内核空间消耗的时间)增长是非常可观的,因此一般只在没有其他方式下才选择.
- 一般来说，应用优先使用fsync或fdatasync而不是通过O_SYNC来将数据写回磁盘，因为只有应用才可以决定何时是最优的时机来执行数据同步。
### O_DSYNC 和 O_RSYNC
- POSIX标准为open调用定义了另外两个同步I/O相关的标志位：O_DSYNC 和 O_RSYNC.
- O_DSYNC标志位指定每次写操作后，只同步数据，不同步元数据。
## 直接I/O
- Linux内核实现了复杂的缓存，缓冲以及设备和应用之间的I/O管理的层次结构。高性能的应用可能希望越过这个复杂的层次结构，进行独立的I/O管理。
- 在open中执行O_DIRECT标志位会使得内核对I/O管理的影响最小化.如果提供O_DIRECT标志位,I/O操作会忽略页缓存机制，直接对用户空间缓冲区和设备进行初始化。所有的I/O操作都是同步的，操作在完成之前不会返回。
- 使用直接I/O时，请求长度，缓冲区对齐以及文件偏移都必须是底层设备扇区大小（通常是512字节）的整数倍。
## 关闭文件
- int close(int fd)
- 系统调用close会取消当前进程的文件描述符fd与其关联的文件之间的映射。调用后先前给定的的文件描述符fd不再有效，内核可以随时重用它，当后续有open调用或creat调用时重新把它作为返回值。
- close调用在成功时返回0，出错时返回-1并相应设置errno。
- 关闭文件操作并非意味着该文件的数据已经被写入到磁盘。
- 调用close可能会使得一个已经解除链接的文件最终从磁盘上删除。
- 因为延迟操作相关的错误可能到了后期才会出现，因此必须检查close的返回值以确保没有漏掉关键错误。


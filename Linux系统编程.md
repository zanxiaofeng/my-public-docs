# Linux编程的概念
## 文件和文件系统
- 文件必须打开才能访问，文件打开方式有只读，只写和读写模式，文件打开后内核会分配一个文件描述符返回给用户空间应用，用户空间应用通过文件描述符来访问该文件。
### 普通文件
- 普通文件包含以字节流（即线性数组）组织的数据。
- 对文件内容的操作总是从某个位置（可以是任意字节）开始，即文件“地址”，又称为文件位置（file location）或文件偏移（file offset）。
### 目录和链接

### 硬链接
- 硬链接支持多个路径指向同一个inode
- 硬链接不能跨文件系统
- 硬链接不支持目录
- ln target link_name
- unlink link_name
- rm link_name
### 符号链接
- 符号链接支持目录，支持跨文件系统
- ln -s target link_name
- unlink link_name
- rm link_name
### 特殊文件
- 字符设备文件，作为线性字节队列来访问。
- 块设备文件，作为字节数组来访问
- 命名管道
- UNIX套接字
### 文件系统和命名空间
- 文件系统是以合理有效的层次结构组织的文件和目录的集合，在文件和目录的全局命名空间中可以分别添加和删除文件系统，这些操作mounting和unmounting，每个文件系统都需要挂载到命名空间的特定位置 即挂载点（mount point）。
- 第一个被挂载的文件系统是在命名空间的根目录/下，称为根文件系统，Linux系统必须有一个根文件系统，而其他文件系统是可选的。

## 进程
### 线程
### 进程层次结构

## 用户和组

## 权限

## 信号

# 文件IO
- 内核会为每个进程维护一个打开文件的列表，该列表称为文件表（file table），文件表是由非负整数进行索引，这些非负整数称为文件描述符（file descriptors，简称fds）。列表的每一项是一个打开文件的信息，包括指向该文件索引节点（inode）内存拷贝的指针以及关联的元数据，如文件位置指针和访问模式。用户空间和内核空间都使用文件描述符作为唯一cookies：打开文件会返回文件描述符，后后续的操作（读写等）都把文件描述符作为基本参数。
- 文件描述符使用C语言的int类型表示。每个Linux进程可打开的文件数是有上限的。文件描述符的范围从1开始，到上限值减一。默认情况下上限值为1024，可以配置这个上限值，最大为1048576.
- 按照惯例，每个进程都至少包含三个文件描述符：0、1和2，除非显示关闭这些描述符。0表示标准输入（stdin），1表示标准输出（stdout），2表示标准错误（stderr）
- 默认情况下，子进程会维护一份父进程的文件表副本。在该副本中打开文件列表及其访问模式，当前文件位置以及其他元数据，都和父进程维护的文件表相同，但是存在一点区别：即当子进程关闭一个文件时，不会影响到父进程的文件表。虽然一般情况下子进程会自己持有一份文件表，但是子进程也可以和父进程共享文件表。
## 文件打开
- 在访问文件之前，必须先通过open()或creat()打开该文件，一旦完成文件读写，还应通过close()关闭该文件.
### 系统调用open()
- int open(const char *name, int flags)
- int open(const char *name, int flags, mode_t mode)
#### open()的flags参数
- flags参数是由一个或多个标志位的按位或组合。它支持三种访问模式：O_RDONLY、O_WRONLY或O_RDWR.
- flags参数还可以和下面这些值进行按位或运算，以修改打开文件的行为：O_APPEND, O_ASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME+, O_NOCTTY, O_NOFOLLOW,O_NONBLOCK, O_SYNC, O_TRUNC
#### 新建文件的所有者
- 确定新建文件的所有者很简单：文件所有者的uid即创建该文件的进程的有效uid。
- 确定文件文件的用户组则相对复杂，默认情况下，使用创建进程的有效gid，System V 和标准Linux都采用这种方式，BSD则有自己的行为方式。
#### 新建文件的权限 - open()的mode参数
- 除非创建了新文件，否则mode参数会被忽略；如果给定O_CREAT flag, 则需要该参数。
- 如果在使用O_CREAT flag时未提供mode参数，结果是未定义的，而且通常很糟糕。
- 当创建文件时，参数mode提供了文件的权限。对于新建的文件，打开文件时不会检查权限，因此可以执行与权限相反的操作，比如以只读方式打开时，却在打开后执行写操作。
- 实际上，最终写入磁盘的权限位是由mode参数和用户的文件创建掩码（umask）执行按位与操作而得到的。umask是进程级属性，通常是由login shell设置，通过调用umask()来修改，支持用户修改新创建的文件和目录的权限。
- 对于系统程序员，在设置权限时通常不需要考虑umask。 为了能限制程序对于新建文件的权限位设置，才有了umask。
### 系统调用creat()
- int creat(const char *name, mode_t mode)
- O_WRONLY|O_CREAT|O_TRUNC的组合经常被使用，因而专门有了这个系统调用。
### 返回值和错误码
- 系统掉调用open和creat在成功时都会返回文件描述符。出错时返回-1，并把errno设置成相应的错误值。
## 文件读
### 定义
- ssize_t read(int fd, void *buf, size_t len)
- 每次调用read函数，会从fd指向的文件的当前偏移开始读取len字节到buf所指向的内存中。执行成功时返回写入buf中的字节数；出错时返回-1，并把errno设置成相应的错误值。
- fd的文件位置指针会向前移动，移动的长度由读取到的字节数决定。如果fd所指向的对象不支持seek操作（比如字符设备文件），则读操作总是从当前位置开始。
### 返回值





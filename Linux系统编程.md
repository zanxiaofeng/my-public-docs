# Linux编程的概念
## 文件和文件系统
- 文件必须打开才能访问，文件打开方式有只读，只写和读写模式，文件打开后内核会分配一个文件描述符返回给用户空间应用，用户空间应用通过文件描述符来访问该文件。
### 普通文件
- 普通文件包含以字节流（即线性数组）组织的数据。
- 对文件内容的操作总是从某个位置（可以是任意字节）开始，即文件“地址”，又称为文件位置（file location）或文件偏移（file offset）。
### 目录和链接

### 硬链接
- 硬链接支持多个路径指向同一个inode
- 硬链接不能跨文件系统
- 硬链接不支持目录
- ln target link_name
- unlink link_name
- rm link_name
### 符号链接
- 符号链接支持目录，支持跨文件系统
- ln -s target link_name
- unlink link_name
- rm link_name
### 特殊文件
- 字符设备文件，作为线性字节队列来访问。
- 块设备文件，作为字节数组来访问
- 命名管道
- UNIX套接字
### 文件系统和命名空间
- 文件系统是以合理有效的层次结构组织的文件和目录的集合，在文件和目录的全局命名空间中可以分别添加和删除文件系统，这些操作mounting和unmounting，每个文件系统都需要挂载到命名空间的特定位置 即挂载点（mount point）。
- 第一个被挂载的文件系统是在命名空间的根目录/下，称为根文件系统，Linux系统必须有一个根文件系统，而其他文件系统是可选的。

## 进程
### 线程
### 进程层次结构

## 用户和组

## 权限

## 信号

# 文件IO
- 内核会为每个进程维护一个打开文件的列表，该列表称为文件表（file table），文件表是由非负整数进行索引，这些非负整数称为文件描述符（file descriptors，简称fds）。列表的每一项是一个打开文件的信息，包括指向该文件索引节点（inode）内存拷贝的指针以及关联的元数据，如文件位置指针和访问模式。用户空间和内核空间都使用文件描述符作为唯一cookies：打开文件会返回文件描述符，后后续的操作（读写等）都把文件描述符作为基本参数。
- 文件描述符使用C语言的int类型表示。每个Linux进程可打开的文件数是有上限的。文件描述符的范围从1开始，到上限值减一。默认情况下上限值为1024，可以配置这个上限值，最大为1048576.
- 按照惯例，每个进程都至少包含三个文件描述符：0、1和2，除非显示关闭这些描述符。0表示标准输入（stdin），1表示标准输出（stdout），2表示标准错误（stderr）
- 默认情况下，子进程会维护一份父进程的文件表副本。在该副本中打开文件列表及其访问模式，当前文件位置以及其他元数据，都和父进程维护的文件表相同，但是存在一点区别：即当子进程关闭一个文件时，不会影响到父进程的文件表。虽然一般情况下子进程会自己持有一份文件表，但是子进程也可以和父进程共享文件表。
## 文件打开
- 在访问文件之前，必须先通过open()或creat()打开该文件，一旦完成文件读写，还应通过close()关闭该文件.
### 系统调用open()
- int open(const char *name, int flags)
- int open(const char *name, int flags, mode_t mode)
#### open()的flags参数
- flags参数是由一个或多个标志位的按位或组合。它支持三种访问模式：O_RDONLY、O_WRONLY或O_RDWR.
- flags参数还可以和下面这些值进行按位或运算，以修改打开文件的行为：O_APPEND, O_ASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME+, O_NOCTTY, O_NOFOLLOW,O_NONBLOCK, O_SYNC, O_TRUNC
#### 新建文件的所有者
- 确定新建文件的所有者很简单：文件所有者的uid即创建该文件的进程的有效uid。
- 确定文件文件的用户组则相对复杂，默认情况下，使用创建进程的有效gid，System V 和标准Linux都采用这种方式，BSD则有自己的行为方式。
#### 新建文件的权限 - open()的mode参数
- 除非创建了新文件，否则mode参数会被忽略；如果给定O_CREAT flag, 则需要该参数。
- 如果在使用O_CREAT flag时未提供mode参数，结果是未定义的，而且通常很糟糕。
- 当创建文件时，参数mode提供了文件的权限。对于新建的文件，打开文件时不会检查权限，因此可以执行与权限相反的操作，比如以只读方式打开时，却在打开后执行写操作。
- 实际上，最终写入磁盘的权限位是由mode参数和用户的文件创建掩码（umask）执行按位与操作而得到的。umask是进程级属性，通常是由login shell设置，通过调用umask()来修改，支持用户修改新创建的文件和目录的权限。
- 对于系统程序员，在设置权限时通常不需要考虑umask。 为了能限制程序对于新建文件的权限位设置，才有了umask。
### 系统调用creat()
- int creat(const char *name, mode_t mode)
- O_WRONLY|O_CREAT|O_TRUNC的组合经常被使用，因而专门有了这个系统调用。
### 返回值和错误码
- 系统掉调用open和creat在成功时都会返回文件描述符。出错时返回-1，并把errno设置成相应的错误值。
## 文件读
### 定义
- ssize_t read(int fd, void *buf, size_t len)
- 每次调用read函数，会从fd指向的文件的当前偏移开始读取len字节到buf所指向的内存中。执行成功时返回写入buf中的字节数；出错时返回-1，并把errno设置成相应的错误值。
- fd的文件位置指针会向前移动，移动的长度由读取到的字节数决定。如果fd所指向的对象不支持seek操作（比如字符设备文件），则读操作总是从当前位置开始。
### 返回值
- 调用返回值等于len。读取到的所有len个字节都被存储在buf中。结果和预期一致。
- 调用返回值小于len，大于0.读取到的字节被存储在buf中。这种情况有很多原因，比如在读取过程中信号中断或在读取中出错，可读的数据大于0小于len，在读取len字节之前EOF等等，再次执行read会把剩余的字节读到buf或者给出错误信息。
- 调用返回0，表示EOF，没有更多可读的数据。
- 由于当前没有数据可用，调用阻塞。在非阻塞模式下不会发生这种情况。
- 返回-1，并把errno设置成EINTR. 表示在读取任何字节之前接收到信号，调用可以重新执行。
- 返回-1，并把errno设置成EAGAIN. 表示由于当前没有数据可用，读操作会阻塞，请求应该稍后再重新执行。这种情况只在非阻塞模式下发生。
- 返回-1，并把errno设置成非EINTR和EAGAIN的一个值.这表示更严重的错误。重新执行不会成功。
## 文件写
### 定义
- ssize_t write(int fd, const void *buf, size_t count)
- write()调用会从文件描述符fd指向的文件的当前位置开始，将buf中至多count个字节写入到文件中。不支持seek的文件（如字符设备）总是从起始位置开始写。
- write()执行成功时，会返回写入的字节数，并更新文件位置。出错时，返回-1，并设置errno值。调用write会返回0,这种返回值没有任何特殊含义，它只是表示写入了零个字节。
### 部分写（Partial Write）
- 对于普通文件，除非发生错误，write操作保证乎会执行整个写请求；但对于其他的文件类型，比如socket，需要循环来保证写了所有请求的字节。使用循环的另一个好处是第二次调用write可能会返回错误值，说明第一次调用为什么只执行了部分写（虽然这种情况并不常见）。
### Append（追加）模式
- 当以Append模式（O_APPEND）打开文件描述符时，写操作不是从文件描述符的当前位置开始，而是从当前文件的末尾开始。
- Append模式可以保证文件位置指针总是执行文件末尾，因此即使存在多个写进程，所有的写操作还是能够保证是追加写。
- Append模式对于某些任务很有用，比如日志文件更新，但对其他很多操作意义不大。
### 非阻塞写
- 以非阻塞模式（O_NONBLOCK）打开文件，当发起写操作时，系统调用会返回-1，并设置errno为EAGAIN。请求可以稍后重新发起。一般而言，对于普通文件，不会出现这种情况。
### write行为
- 当write调用返回时，内核已经把数据从提供的缓冲区中拷贝到内核缓冲区中，但不保证数据已经写入目的地。实际上，write调用执行非常快，因此不可能保证数据 已经写到目的地。处理器和硬盘之间的性能差异使得这种情况非常明显。
- 

